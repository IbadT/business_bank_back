# ============================================================================
# NGINX API GATEWAY CONFIGURATION
# Этот файл настраивает Nginx как единую точку входа (API Gateway) для всех
# микросервисов. Nginx принимает все входящие HTTP запросы и проксирует их
# на соответствующие backend сервисы, обеспечивая load balancing, rate limiting,
# compression и единую точку мониторинга.
# ============================================================================

# ----------------------------------------------------------------------------
# EVENTS БЛОК - Настройки обработки соединений
# ----------------------------------------------------------------------------
events {
    # Максимальное количество одновременных соединений на один worker процесс
    # 1024 соединения × количество worker'ов = общая пропускная способность
    # Для production можно увеличить до 4096 или больше
    worker_connections 1024;
    
    # epoll - эффективный метод обработки событий для Linux
    # Использует kernel-level механизм для отслеживания множества соединений
    # Альтернативы: kqueue (FreeBSD/macOS), select (универсальный, но медленный)
    use epoll;
}

# ----------------------------------------------------------------------------
# HTTP БЛОК - Основной контекст для всех HTTP настроек
# ----------------------------------------------------------------------------
http {
    # ----------------------------------------------------------------------------
    # ОСНОВНЫЕ НАСТРОЙКИ
    # ----------------------------------------------------------------------------
    
    # Подключаем файл с MIME типами (определяет Content-Type для разных файлов)
    # /etc/nginx/mime.types содержит mapping расширений файлов к MIME типам
    # Например: .json -> application/json, .html -> text/html
    include /etc/nginx/mime.types;
    
    # MIME тип по умолчанию для файлов без расширения или неизвестных типов
    # application/octet-stream означает "бинарные данные" - браузер скачает файл
    default_type application/octet-stream;

    # ----------------------------------------------------------------------------
    # ЛОГИРОВАНИЕ - Настройка форматов и путей для логов
    # ----------------------------------------------------------------------------
    
    # Определяем custom формат лога с детальной информацией о запросах
    # Этот формат включает timing метрики для анализа производительности
    log_format main '$remote_addr - $remote_user [$time_local] "$request" '
                    # $remote_addr - IP адрес клиента
                    # $remote_user - имя пользователя (если Basic Auth)
                    # $time_local - локальное время запроса
                    # $request - полная строка запроса (GET /api/... HTTP/1.1)
                    
                    '$status $body_bytes_sent "$http_referer" '
                    # $status - HTTP статус ответа (200, 404, 500...)
                    # $body_bytes_sent - размер тела ответа в байтах
                    # $http_referer - откуда пришел клиент (Referer header)
                    
                    '"$http_user_agent" "$http_x_forwarded_for" '
                    # $http_user_agent - браузер/клиент (Chrome, curl...)
                    # $http_x_forwarded_for - реальный IP если за proxy/CDN
                    
                    'rt=$request_time uct="$upstream_connect_time" '
                    # rt=$request_time - общее время обработки запроса в секундах
                    # uct=$upstream_connect_time - время подключения к backend
                    
                    'uht="$upstream_header_time" urt="$upstream_response_time"';
                    # uht=$upstream_header_time - время до получения header от backend
                    # urt=$upstream_response_time - полное время ответа от backend
                    # Эти метрики помогают найти узкие места в производительности

    # Путь к access логу (все успешные запросы) с использованием формата 'main'
    # Логи пишутся в Docker volume nginx_logs для персистентности
    access_log /var/log/nginx/access.log main;
    
    # Путь к error логу (ошибки и предупреждения) с уровнем warn
    # Уровни: debug, info, notice, warn, error, crit, alert, emerg
    # warn - логирует предупреждения и все более серьезные ошибки
    error_log /var/log/nginx/error.log warn;

    # ----------------------------------------------------------------------------
    # ПРОИЗВОДИТЕЛЬНОСТЬ - Оптимизация обработки запросов
    # ----------------------------------------------------------------------------
    
    # sendfile - использует kernel-level системный вызов для отправки файлов
    # Избегает копирования данных между kernel и user space - НАМНОГО быстрее
    # Особенно эффективно для статических файлов
    sendfile on;
    
    # tcp_nopush - отправляет HTTP заголовки в одном пакете с началом файла
    # Работает только с sendfile on. Уменьшает количество TCP пакетов
    # Полезно для больших файлов - меньше network overhead
    tcp_nopush on;
    
    # tcp_nodelay - отключает алгоритм Nagle (buffering маленьких пакетов)
    # Отправляет данные немедленно без ожидания накопления буфера
    # Уменьшает latency для API запросов (важно для real-time)
    tcp_nodelay on;
    
    # keepalive_timeout - время (в секундах) для поддержания keep-alive соединений
    # 65 секунд - клиент может переиспользовать TCP соединение для нескольких запросов
    # Экономит время на TCP handshake, особенно важно для HTTPS (TLS handshake дорогой)
    keepalive_timeout 65;
    
    # types_hash_max_size - размер hash таблицы для MIME типов
    # 2048 - достаточно для стандартного набора типов из mime.types
    # Увеличь если добавляешь много custom MIME типов
    types_hash_max_size 2048;

    # ----------------------------------------------------------------------------
    # COMPRESSION - Сжатие ответов для уменьшения трафика
    # ----------------------------------------------------------------------------
    
    # gzip on - включает gzip компрессию ответов
    # Уменьшает размер передаваемых данных в 3-10 раз (особенно JSON, HTML, CSS)
    # Клиент должен поддерживать gzip (header: Accept-Encoding: gzip)
    gzip on;
    
    # gzip_vary - добавляет заголовок "Vary: Accept-Encoding" в ответ
    # Сообщает proxy/CDN что ответ зависит от Accept-Encoding клиента
    # Важно для правильного кэширования разных версий (сжатой и несжатой)
    gzip_vary on;
    
    # gzip_min_length - минимальный размер ответа (в байтах) для сжатия
    # 1000 байт (1KB) - файлы меньше этого размера не сжимаются
    # Сжатие маленьких файлов не эффективно (overhead > выгода)
    gzip_min_length 1000;
    
    # gzip_comp_level - уровень компрессии от 1 (быстро, слабо) до 9 (медленно, сильно)
    # 6 - оптимальный баланс между CPU usage и степенью сжатия
    # Уровни 7-9 дают минимальный прирост, но сильно нагружают CPU
    gzip_comp_level 6;
    
    # gzip_types - типы контента для сжатия (text/html сжимается всегда по умолчанию)
    # Указываем все текстовые форматы которые хорошо сжимаются
    gzip_types text/plain text/css text/xml text/javascript 
               # Обычный текст, CSS стили, XML документы, JavaScript код
               
               application/json application/javascript application/xml+rss 
               # JSON API ответы, JS приложения, RSS ленты
               
               application/rss+xml font/truetype font/opentype 
               # RSS feeds, шрифты TrueType и OpenType
               
               application/vnd.ms-fontobject image/svg+xml;
               # Microsoft шрифты, SVG изображения (векторная графика в XML)
               # НЕ сжимаем: image/jpeg, image/png - они уже сжаты

    # ----------------------------------------------------------------------------
    # UPSTREAM DEFINITIONS - Определение backend серверов
    # ----------------------------------------------------------------------------
    # Upstream блоки определяют группы backend серверов для load balancing
    # Nginx автоматически распределяет запросы между серверами в группе
    # Преимущества: отказоустойчивость, горизонтальное масштабирование

    # Matematika Service - расчеты и генерация выписок
    upstream matematika_backend {
        # least_conn - метод балансировки нагрузки
        # Отправляет запрос на сервер с наименьшим количеством активных соединений
        # Альтернативы: round_robin (по кругу), ip_hash (sticky sessions по IP)
        # least_conn оптимален для долгих операций (генерация выписок)
        least_conn;
        
        # Определяем backend сервер
        # matematika:8080 - имя Docker контейнера и порт (Docker DNS резолвит имя)
        # max_fails=3 - после 3 неудачных попыток сервер помечается как недоступный
        # fail_timeout=30s - сервер недоступен 30 секунд, потом Nginx попробует снова
        server matematika:8080 max_fails=3 fail_timeout=30s;
        
        # Для горизонтального масштабирования добавь больше инстансов:
        # server matematika2:8080 max_fails=3 fail_timeout=30s;
        # server matematika3:8080 max_fails=3 fail_timeout=30s;
        # Nginx автоматически распределит нагрузку между всеми серверами
        
        # keepalive 32 - поддерживает 32 idle соединения к backend
        # Переиспользование TCP соединений экономит время на handshake
        # Особенно важно для частых запросов - значительно снижает latency
        keepalive 32;
    }

    # Maska Service - форматирование (закомментировано, пока сервис не добавлен)
    # Раскомментируй когда запустишь Maska service
    # upstream maska_backend {
    #     least_conn;
    #     server maska:3000 max_fails=3 fail_timeout=30s;
    #     keepalive 32;
    # }

    # Shared Service - общие данные (закомментировано, пока сервис не добавлен)
    # Раскомментируй когда запустишь Shared service
    # upstream shared_backend {
    #     least_conn;
    #     server shared:8081 max_fails=3 fail_timeout=30s;
    #     keepalive 32;
    # }

    # ----------------------------------------------------------------------------
    # RATE LIMITING - Защита от перегрузки и DDoS атак
    # ----------------------------------------------------------------------------
    # limit_req_zone создает shared memory зону для отслеживания rate limits
    # Защищает backend от перегрузки и предотвращает abuse API
    
    # Общее ограничение для всех API endpoints
    # $binary_remote_addr - ключ лимита (бинарное представление IP клиента)
    # Бинарный формат занимает меньше памяти чем текстовый IP
    # zone=api_limit:10m - имя зоны и размер (10MB хватает на ~160,000 IP адресов)
    # rate=100r/m - максимум 100 requests per minute на один IP
    # Превышение лимита -> 503 Service Temporarily Unavailable
    limit_req_zone $binary_remote_addr zone=api_limit:10m rate=100r/m;
    
    # Специальное ограничение для генерации выписок (тяжелая операция)
    # zone=statement_limit:10m - отдельная зона для выписок
    # rate=10r/m - всего 10 запросов в минуту на один IP
    # Генерация выписки затратная операция (CPU, Kafka, DB) - строже лимит
    limit_req_zone $binary_remote_addr zone=statement_limit:10m rate=10r/m;

    # ----------------------------------------------------------------------------
    # HTTP SERVER - Основной сервер для обработки запросов
    # ----------------------------------------------------------------------------
    # server блок определяет виртуальный сервер (virtual host)
    # Может быть несколько server блоков для разных доменов или портов
    
    server {
        # listen 80 - слушаем порт 80 (стандартный HTTP)
        # Nginx принимает все входящие соединения на этом порту
        # В Docker контейнере это внутренний порт, маппится на host через docker-compose
        listen 80;
        
        # server_name - имя сервера (домен)
        # localhost - для локальной разработки
        # В production замени на реальный домен: api.example.com
        # Можно указать несколько: server_name api.example.com api2.example.com;
        server_name localhost;

        # Health check endpoint для мониторинга
        # Используется Docker healthcheck и внешними мониторинг системами
        location /nginx-health {
            # access_log off - НЕ логируем health check запросы
            # Они слишком частые (каждые 10s) - засоряют логи
            access_log off;
            
            # return 200 - возвращаем HTTP 200 OK с текстом "healthy"
            # Быстрый ответ без обращения к backend
            # Проверяет что Nginx процесс работает
            return 200 "healthy\n";
            
            # add_header - добавляем Content-Type заголовок
            # text/plain - указываем что это обычный текст, не HTML
            add_header Content-Type text/plain;
        }

        # В production раскомментируй для автоматического редиректа на HTTPS:
        # return 301 https://$host$request_uri;
        # 301 - permanent redirect
        # $host - имя хоста из запроса
        # $request_uri - полный URI включая query params
        # Все HTTP запросы будут перенаправлены на HTTPS (безопасность)

        # Подключаем файл с роутами для API endpoints
        # /etc/nginx/conf.d/api-routes.conf содержит все location блоки
        # Вынесено в отдельный файл для удобства управления роутами
        # Путь /etc/nginx/conf.d/ - стандартная директория для include файлов
        include /etc/nginx/conf.d/api-routes.conf;
    }

    # ----------------------------------------------------------------------------
    # HTTPS SERVER - Для production с SSL/TLS шифрованием
    # ----------------------------------------------------------------------------
    # Закомментировано для локальной разработки
    # Раскомментируй и настрой для production deployment
    
    # server {
    #     # listen 443 ssl http2 - слушаем порт 443 (стандартный HTTPS)
    #     # ssl - включает SSL/TLS шифрование
    #     # http2 - включает HTTP/2 протокол (мультиплексирование, server push)
    #     listen 443 ssl http2;
    #     
    #     # Доменное имя для HTTPS сервера
    #     server_name localhost;
    #
    #     # SSL сертификаты (получи через Let's Encrypt или купи)
    #     # ssl_certificate - путь к публичному сертификату (.pem или .crt)
    #     # Содержит публичный ключ и информацию о домене
    #     ssl_certificate /etc/nginx/ssl/cert.pem;
    #     
    #     # ssl_certificate_key - путь к приватному ключу
    #     # КРИТИЧЕСКИ ВАЖНО: держи в секрете, не коммить в Git!
    #     # Используется для дешифровки трафика
    #     ssl_certificate_key /etc/nginx/ssl/key.pem;
    #
    #     # SSL протоколы - разрешаем только безопасные версии
    #     # TLSv1.2, TLSv1.3 - современные, безопасные протоколы
    #     # SSLv3, TLSv1.0, TLSv1.1 - устаревшие, имеют уязвимости (POODLE, BEAST)
    #     ssl_protocols TLSv1.2 TLSv1.3;
    #     
    #     # ssl_ciphers - алгоритмы шифрования
    #     # HIGH - сильные шифры (AES256, AES128)
    #     # !aNULL - исключаем шифры без аутентификации
    #     # !MD5 - исключаем MD5 (слабый, уязвим к коллизиям)
    #     ssl_ciphers HIGH:!aNULL:!MD5;
    #     
    #     # ssl_prefer_server_ciphers - сервер выбирает cipher suite
    #     # on - используем список шифров сервера (более безопасный)
    #     # Игнорируем предпочтения клиента
    #     ssl_prefer_server_ciphers on;
    #
    #     # Подключаем те же API routes что и для HTTP
    #     # Роуты одинаковые, только протокол разный (HTTP vs HTTPS)
    #     include /etc/nginx/conf.d/api-routes.conf;
    # }
}
# Конец http блока - все HTTP настройки выше должны быть внутри http { }